package com.gpetuhov.android.feature_profile_impl.di.components

import com.gpetuhov.android.core_db_api.di.CoreDbApi
import com.gpetuhov.android.core_utils.di.api.CoreUtilsApi
import com.gpetuhov.android.core_utils.di.scopes.PerFeature
import com.gpetuhov.android.feature_profile_api.ProfileFeatureApi
import com.gpetuhov.android.feature_profile_impl.di.dependencies.ProfileFeatureDependencies
import com.gpetuhov.android.feature_profile_impl.di.modules.ProfileFeatureModule
import com.gpetuhov.android.feature_profile_impl.ui.ProfileActivity
import dagger.Component

// ProfileFeatureComponent provides class instances with PerFeature scope.

// ProfileFeatureComponent depends on ProfileFeatureDependencies
// (Dagger allows using interfaces, not only components),
// so it can provide instances of Utils and DbClientApi.

// We have 2 (!!!) components here:
// ProfileFeatureComponent and ProfileFeatureDependenciesComponent.
// ProfileFeatureComponent depends on ProfileFeatureDependencies interface,
// which is implemented by ProfileFeatureDependenciesComponent component.

// But we need to initialize ProfileFeatureDependenciesComponent with concrete
// implementations of CoreUtilsApi and CoreDbApi and provide this concrete
// ProfileFeatureDependenciesComponent to ProfileFeatureComponent.
// We cannot do it here, because from the Feature module we have access
// only to api modules. That's why this is done in the application module,
// which has access both to api and impl modules.

// This allows us to have such an architecture, where Features know nothing
// of each other's implementation, only external apis.
// All interconnection is done in the application module, which is the only one
// that has access both to api and impl modules.

@Component(
    modules = [ProfileFeatureModule::class],

    // Dagger allows using interfaces here, not only components.
    // This will make Dagger generate profileFeatureDependencies() method,
    // where we will pass ProfileFeatureDependenciesComponent through initAndGet() (in the application module).
    dependencies = [ProfileFeatureDependencies::class]
)
@PerFeature
abstract class ProfileFeatureComponent : ProfileFeatureApi {

    companion object {
        private var profileFeatureComponent: ProfileFeatureComponent? = null

        // Create and initialize ProfileFeatureComponent
        // with concrete initialized implementation of ProfileFeatureDependencies.
        // This is called in the application module.
        fun initAndGet(profileFeatureDependencies: ProfileFeatureDependencies): ProfileFeatureApi? {
            if (profileFeatureComponent == null) {
                profileFeatureComponent = DaggerProfileFeatureComponent.builder()
                    // This method is generated by Dagger, because we added dependencies in Component annotations.
                    .profileFeatureDependencies(profileFeatureDependencies)
                    .build()
            }
            return profileFeatureComponent
        }

        // Get component, if initialized.
        // This can be called only after initAndGet()
        fun get(): ProfileFeatureComponent? {
            if (profileFeatureComponent == null) {
                throw RuntimeException("You must call 'initAndGet()' method")
            }
            return profileFeatureComponent
        }

        // Manually control scope lifecycle as usual
        fun resetComponent() {
            profileFeatureComponent = null
        }
    }

    // ProfileActivity is in the same module,
    // so we can inject dependencies into it as usual.
    abstract fun inject(profileActivity: ProfileActivity)


    // ProfileFeatureDependenciesComponent depends on CoreUtilsApi and CoreDbApi,
    // so it can provide instances of Utils and DbClientApi.
    // ProfileFeatureDependenciesComponent implements ProfileFeatureDependencies,
    // which is equivalent to:
    // interface ProfileFeatureDependenciesComponent {
    //     fun utils(): Utils
    //     fun dbClientApi(): DbClientApi
    // }
    // So components, that depend on ProfileFeatureDependenciesComponent,
    // can also provide instances of Utils and DbClientApi.

    // Notice that we have a component inside a component here.
    // Dagger can handle this!

    @Component(dependencies = [
        // Dagger allows interfaces here.
        // This will make Dagger generate coreUtilsApi() and coreDbApi() methods,
        // where we will pass CoreUtilsComponent and CoreDbComponent (in the application module).
        CoreUtilsApi::class,
        CoreDbApi::class
    ])
    @PerFeature
    interface ProfileFeatureDependenciesComponent : ProfileFeatureDependencies
}